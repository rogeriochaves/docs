<!DOCTYPE html>
<html>
  <head>
    <title>Stream</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/elixir.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <section id="content">
      <div class="breadcrumbs">Elixir v1.1.0-dev &rarr; <a href="overview.html">Overview</a> &rarr; <a href="Stream.html">Stream</a></div>
      <h1>
        Stream
        
      </h1>

      <ul class="summary_links">
        
          <li><a href="#summary">Summary</a></li>
        
        
          <li><a href="#types_details">Types</a></li>
        
        
          <li><a href="#functions_details">Functions</a></li>
        
        
        
      </ul>

      
        <section id="moduledoc" class="docstring">
          <p>Module for creating and composing streams.</p>
<p>Streams are composable, lazy enumerables. Any enumerable that generates
items one by one during enumeration is called a stream. For example,
Elixir’s <a href="Range.html"><code class="inline">Range</code></a> is a stream:</p>
<pre><code>iex&gt; range = 1..5
1..5
iex&gt; Enum.map range, &amp;(&amp;1 * 2)
[2,4,6,8,10]</code></pre>
<p>In the example above, as we mapped over the range, the elements being
enumerated were created one by one, during enumeration. The <a href="Stream.html"><code class="inline">Stream</code></a>
module allows us to map the range, without triggering its enumeration:</p>
<pre><code>iex&gt; range = 1..3
iex&gt; stream = Stream.map(range, &amp;(&amp;1 * 2))
iex&gt; Enum.map(stream, &amp;(&amp;1 + 1))
[3,5,7]</code></pre>
<p>Notice we started with a range and then we created a stream that is
meant to multiply each item in the range by 2. At this point, no
computation was done yet. Just when <a href="Enum.html#map/2"><code class="inline">Enum.map/2</code></a> is called we
enumerate over each item in the range, multiplying it by 2 and adding 1.
We say the functions in <a href="Stream.html"><code class="inline">Stream</code></a> are <em>lazy</em> and the functions in <a href="Enum.html"><code class="inline">Enum</code></a>
are <em>eager</em>.</p>
<p>Due to their laziness, streams are useful when working with large
(or even infinite) collections. When chaining many operations with <a href="Enum.html"><code class="inline">Enum</code></a>,
intermediate lists are created, while <a href="Stream.html"><code class="inline">Stream</code></a> creates a recipe of
computations that are executed at a later moment. Let’s see another
example:</p>
<pre><code>1..3 |&gt;
  Enum.map(&amp;IO.inspect(&amp;1)) |&gt;
  Enum.map(&amp;(&amp;1 * 2)) |&gt;
  Enum.map(&amp;IO.inspect(&amp;1))
1
2
3
2
4
6
#=&gt; [2,4,6]</code></pre>
<p>Notice that we first printed each item in the list, then multiplied each
element by 2 and finally printed each new value. In this example, the list
was enumerated three times. Let’s see an example with streams:</p>
<pre><code>stream = 1..3 |&gt;
  Stream.map(&amp;IO.inspect(&amp;1)) |&gt;
  Stream.map(&amp;(&amp;1 * 2)) |&gt;
  Stream.map(&amp;IO.inspect(&amp;1))
Enum.to_list(stream)
1
2
2
4
3
6
#=&gt; [2,4,6]</code></pre>
<p>Although the end result is the same, the order in which the items were
printed changed! With streams, we print the first item and then print
its double. In this example, the list was enumerated just once!</p>
<p>That’s what we meant when we first said that streams are composable,
lazy enumerables. Notice we could call <a href="Stream.html#map/2"><code class="inline">Stream.map/2</code></a> multiple times,
effectively composing the streams and they are lazy. The computations
are performed only when you call a function from the <a href="Enum.html"><code class="inline">Enum</code></a> module.</p>
<h2>Creating Streams</h2>
<p>There are many functions in Elixir’s standard library that return
streams, some examples are:</p>
<ul>
<li><a href="IO.html#stream/2"><code class="inline">IO.stream/2</code></a>         - streams input lines, one by one
</li>
<li><a href="URI.html#query_decoder/1"><code class="inline">URI.query_decoder/1</code></a> - decodes a query string, pair by pair
</li>
</ul>
<p>This module also provides many convenience functions for creating streams,
like <a href="Stream.html#cycle/1"><code class="inline">Stream.cycle/1</code></a>, <a href="Stream.html#unfold/2"><code class="inline">Stream.unfold/2</code></a>, <a href="Stream.html#resource/3"><code class="inline">Stream.resource/3</code></a> and more.</p>
<p>Note the functions in this module are guaranteed to return enumerables.
Since enumerables can have different shapes (structs, anonymous functions,
and so on), the functions in this module may return any of those shapes
and that it may change at any time. For example, a function that today
returns an anonymous function may return a struct in future releases.</p>

        </section>
      

      
        <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L1" class="view_source">Source</a>
      

      
        <h2 id="summary">Summary<span class="detail_header_links"><a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></span></h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#chunk/2">chunk(enum, n)</a></td>
  
    <td class="summary_synopsis"><p>Shortcut to <code class="inline">chunk(enum, n, n)</code></p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#chunk/4">chunk(enum, n, step, pad \\ nil)</a></td>
  
    <td class="summary_synopsis"><p>Streams the enumerable in chunks, containing <code class="inline">n</code> items each, where
each new chunk starts <code class="inline">step</code> elements into the enumerable</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#chunk_by/2">chunk_by(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Chunks the <code class="inline">enum</code> by buffering elements for which <code class="inline">fun</code> returns
the same value and only emit them when <code class="inline">fun</code> returns a new value
or the <code class="inline">enum</code> finishes</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#concat/1">concat(enumerables)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that enumerates each enumerable in an enumerable</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#concat/2">concat(first, second)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that enumerates the first argument, followed by the second</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#cycle/1">cycle(enumerable)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that cycles through the given enumerable,
infinitely</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#drop/2">drop(enum, n)</a></td>
  
    <td class="summary_synopsis"><p>Lazily drops the next <code class="inline">n</code> items from the enumerable</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#drop_while/2">drop_while(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Lazily drops elements of the enumerable while the given
function returns <code class="inline">true</code></p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#each/2">each(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Executes the given function for each item</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#filter/2">filter(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that filters elements according to
the given function on enumeration</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#filter_map/3">filter_map(enum, filter, mapper)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that filters and then maps elements according
to given functions</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#flat_map/2">flat_map(enum, mapper)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that will apply the given function on enumeration and
flatten the result</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#interval/1">interval(n)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that emits a value every <code class="inline">n</code> milliseconds</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#into/3">into(enum, collectable, transform \\ fn x -&gt; x end)</a></td>
  
    <td class="summary_synopsis"><p>Injects the stream values into the given collectable as a side-effect</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#iterate/2">iterate(start_value, next_fun)</a></td>
  
    <td class="summary_synopsis"><p>Emits a sequence of values, starting with <code class="inline">start_value</code>. Successive
values are generated by calling <code class="inline">next_fun</code> on the previous value</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#map/2">map(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that will apply the given function on
enumeration</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reject/2">reject(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that will reject elements according to
the given function on enumeration</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#repeatedly/1">repeatedly(generator_fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns a stream generated by calling <code class="inline">generator_fun</code> repeatedly</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#resource/3">resource(start_fun, next_fun, after_fun)</a></td>
  
    <td class="summary_synopsis"><p>Emits a sequence of values for the given resource</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#run/1">run(stream)</a></td>
  
    <td class="summary_synopsis"><p>Runs the given stream</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#scan/2">scan(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#scan/3">scan(enum, acc, fun)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation. Uses the given <code class="inline">acc</code> as the starting value</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take/2">take(enum, n)</a></td>
  
    <td class="summary_synopsis"><p>Lazily takes the next <code class="inline">n</code> items from the enumerable and stops
enumeration</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take_every/2">take_every(enum, n)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that takes every <code class="inline">n</code> item from the enumerable</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take_while/2">take_while(enum, fun)</a></td>
  
    <td class="summary_synopsis"><p>Lazily takes elements of the enumerable while the given
function returns <code class="inline">true</code></p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#timer/1">timer(n)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that emits a single value after <code class="inline">n</code> milliseconds</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#transform/3">transform(enum, acc, reducer)</a></td>
  
    <td class="summary_synopsis"><p>Transforms an existing stream</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unfold/2">unfold(next_acc, next_fun)</a></td>
  
    <td class="summary_synopsis"><p>Emits a sequence of values for the given accumulator</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#uniq/2">uniq(enum, fun \\ fn x -&gt; x end)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream that only emits elements if they are unique</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#with_index/1">with_index(enum)</a></td>
  
    <td class="summary_synopsis"><p>Creates a stream where each item in the enumerable will
be wrapped in a tuple alongside its index</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#zip/2">zip(left, right)</a></td>
  
    <td class="summary_synopsis"><p>Zips two collections together, lazily</p>
</td>
  
</tr>

        </table>
      

      
        <section id="types_details" class="details_list">
          <h2>Types <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></h2>
          <div class="type_detail">
  <p class="typespec" id="t:acc/0">
    <a href="#t:acc/0">acc</a> :: any
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:element/0">
    <a href="#t:element/0">element</a> :: any
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:index/0">
    <a href="#t:index/0">index</a> :: non_neg_integer
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:default/0">
    <a href="#t:default/0">default</a> :: any
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:t/0">
    <a href="#t:t/0">t</a> :: %Stream{accs: term, done: term, enum: term, funs: term}
  </p>
  
</div>

        </section>
      

      
        <section id="functions_details" class="details_list">
          <h2>Functions</h2>
          <section class="detail">
  <div class="detail_header" id="chunk/2">
    <span class="signature"><strong>chunk(enum, n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#chunk/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunk(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, non_neg_integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Shortcut to <code class="inline">chunk(enum, n, n)</code>.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L125" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="chunk/4">
    <span class="signature"><strong>chunk(enum, n, step, pad \\ nil)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#chunk/4" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunk(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, non_neg_integer, non_neg_integer, <a href="Enumerable.html#t:t/0">Enumerable.t</a> | nil) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Streams the enumerable in chunks, containing <code class="inline">n</code> items each, where
each new chunk starts <code class="inline">step</code> elements into the enumerable.</p>
<p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">n</code>, i.e.
chunks do not overlap. If the final chunk does not have <code class="inline">n</code>
elements to fill the chunk, elements are taken as necessary
from <code class="inline">pad</code> if it was passed. If <code class="inline">pad</code> is passed and does not
have enough elements to fill the chunk, then the chunk is
returned anyway with less than <code class="inline">n</code> elements. If <code class="inline">pad</code> is not
passed at all or is <code class="inline">nil</code>, then the partial chunk is discarded
from the result.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 2) |&gt; Enum.to_list
[[1, 2], [3, 4], [5, 6]]

iex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |&gt; Enum.to_list
[[1, 2, 3], [3, 4, 5]]

iex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |&gt; Enum.to_list
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |&gt; Enum.to_list
[[1, 2, 3], [4, 5, 6]]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L157" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="chunk_by/2">
    <span class="signature"><strong>chunk_by(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#chunk_by/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunk_by(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Chunks the <code class="inline">enum</code> by buffering elements for which <code class="inline">fun</code> returns
the same value and only emit them when <code class="inline">fun</code> returns a new value
or the <code class="inline">enum</code> finishes.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
iex&gt; Enum.to_list(stream)
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L190" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="concat/1">
    <span class="signature"><strong>concat(enumerables)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#concat/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>concat(<a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that enumerates each enumerable in an enumerable.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.concat([1..3, 4..6, 7..9])
iex&gt; Enum.to_list(stream)
[1,2,3,4,5,6,7,8,9]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L780" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="concat/2">
    <span class="signature"><strong>concat(first, second)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#concat/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>concat(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, <a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that enumerates the first argument, followed by the second.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.concat(1..3, 4..6)
iex&gt; Enum.to_list(stream)
[1,2,3,4,5,6]

iex&gt; stream1 = Stream.cycle([1, 2, 3])
iex&gt; stream2 = Stream.cycle([4, 5, 6])
iex&gt; stream = Stream.concat(stream1, stream2)
iex&gt; Enum.take(stream, 6)
[1,2,3,1,2,3]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L801" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="cycle/1">
    <span class="signature"><strong>cycle(enumerable)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#cycle/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>cycle(<a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that cycles through the given enumerable,
infinitely.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.cycle([1,2,3])
iex&gt; Enum.take(stream, 5)
[1,2,3,1,2]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L892" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="drop/2">
    <span class="signature"><strong>drop(enum, n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#drop/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>drop(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, non_neg_integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Lazily drops the next <code class="inline">n</code> items from the enumerable.</p>
<p>If a negative <code class="inline">n</code> is given, it will drop the last <code class="inline">n</code> items from
the collection. Note that the mechanism by which this is implemented
will delay the emission of any item until <code class="inline">n</code> additional items have
been emitted by the enum.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.drop(1..10, 5)
iex&gt; Enum.to_list(stream)
[6,7,8,9,10]

iex&gt; stream = Stream.drop(1..10, -5)
iex&gt; Enum.to_list(stream)
[1,2,3,4,5]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L224" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="drop_while/2">
    <span class="signature"><strong>drop_while(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#drop_while/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>drop_while(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Lazily drops elements of the enumerable while the given
function returns <code class="inline">true</code>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.drop_while(1..10, &amp;(&amp;1 &lt;= 5))
iex&gt; Enum.to_list(stream)
[6,7,8,9,10]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L264" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="each/2">
    <span class="signature"><strong>each(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#each/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>each(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> term)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Executes the given function for each item.</p>
<p>Useful for adding side effects (like printing) to a stream.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.each([1, 2, 3], fn(x) -&gt; send self, x end)
iex&gt; Enum.to_list(stream)
iex&gt; receive do: (x when is_integer(x) -&gt; x)
1
iex&gt; receive do: (x when is_integer(x) -&gt; x)
2
iex&gt; receive do: (x when is_integer(x) -&gt; x)
3</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L286" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="filter/2">
    <span class="signature"><strong>filter(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#filter/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>filter(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that filters elements according to
the given function on enumeration.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.filter([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
iex&gt; Enum.to_list(stream)
[2]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L323" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="filter_map/3">
    <span class="signature"><strong>filter_map(enum, filter, mapper)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#filter_map/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>filter_map(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term)), (<a href="#t:element/0">element</a> -> any)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that filters and then maps elements according
to given functions.</p>
<p>Exists for symmetry with <a href="Enum.html#filter_map/3"><code class="inline">Enum.filter_map/3</code></a>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.filter_map(1..6, fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))
iex&gt; Enum.to_list(stream)
[4,8,12]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L341" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="flat_map/2">
    <span class="signature"><strong>flat_map(enum, mapper)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#flat_map/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>flat_map(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> <a href="Enumerable.html#t:t/0">Enumerable.t</a>)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that will apply the given function on enumeration and
flatten the result.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.flat_map([1, 2, 3], fn(x) -&gt; [x, x * 2] end)
iex&gt; Enum.to_list(stream)
[1, 2, 2, 4, 3, 6]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L307" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="interval/1">
    <span class="signature"><strong>interval(n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#interval/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>interval(non_neg_integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that emits a value every <code class="inline">n</code> milliseconds.</p>
<p>The values emitted are an increasing counter starting at <code class="inline">0</code>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.interval(10) |&gt; Enum.take(10)
[0,1,2,3,4,5,6,7,8,9]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L357" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="into/3">
    <span class="signature"><strong>into(enum, collectable, transform \\ fn x -&gt; x end)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#into/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Injects the stream values into the given collectable as a side-effect.</p>
<p>This function is often used with <a href="#run/1"><code class="inline">run/1</code></a> since any evaluation
is delayed until the stream is executed. See <a href="#run/1"><code class="inline">run/1</code></a> for an example.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L371" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="iterate/2">
    <span class="signature"><strong>iterate(start_value, next_fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#iterate/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>iterate(<a href="#t:element/0">element</a>, (<a href="#t:element/0">element</a> -> <a href="#t:element/0">element</a>)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Emits a sequence of values, starting with <code class="inline">start_value</code>. Successive
values are generated by calling <code class="inline">next_fun</code> on the previous value.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.iterate(0, &amp;(&amp;1+1)) |&gt; Enum.take(5)
[0,1,2,3,4]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L949" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="map/2">
    <span class="signature"><strong>map(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#map/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>map(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that will apply the given function on
enumeration.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.map([1, 2, 3], fn(x) -&gt; x * 2 end)
iex&gt; Enum.to_list(stream)
[2,4,6]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L414" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="reject/2">
    <span class="signature"><strong>reject(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#reject/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reject(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that will reject elements according to
the given function on enumeration.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.reject([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
iex&gt; Enum.to_list(stream)
[1,3]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L430" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="repeatedly/1">
    <span class="signature"><strong>repeatedly(generator_fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#repeatedly/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>repeatedly((() -> <a href="#t:element/0">element</a>)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Returns a stream generated by calling <code class="inline">generator_fun</code> repeatedly.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.repeatedly(&amp;:random.uniform/0) |&gt; Enum.take(3)
[0.4435846174457203, 0.7230402056221108, 0.94581636451987]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L969" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="resource/3">
    <span class="signature"><strong>resource(start_fun, next_fun, after_fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#resource/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>resource((() -> <a href="#t:acc/0">acc</a>), (<a href="#t:acc/0">acc</a> -> {<a href="#t:element/0">element</a>, <a href="#t:acc/0">acc</a>} | nil), (<a href="#t:acc/0">acc</a> -> term)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Emits a sequence of values for the given resource.</p>
<p>Similar to <code class="inline">transform/2</code> but the initial accumulated value is
computed lazily via <code class="inline">start_fun</code> and executes an <code class="inline">after_fun</code> at
the end of enumeration (both in cases of success and failure).</p>
<p>Successive values are generated by calling <code class="inline">next_fun</code> with the
previous accumulator (the initial value being the result returned
by <code class="inline">start_fun</code>) and it must return a tuple containing a list
of items to be emitted and the next accumulator. The enumeration
finishes if it returns <code class="inline">{:halt, acc}</code>.</p>
<p>As the name says, this function is useful to stream values from
resources.</p>
<h2>Examples</h2>
<pre><code>Stream.resource(fn -&gt; File.open!(&quot;sample&quot;) end,
                fn file -&gt;
                  case IO.read(file, :line) do
                    data when is_binary(data) -&gt; {[data], file}
                    _ -&gt; {:halt, file}
                  end
                end,
                fn file -&gt; File.close(file) end)</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L1014" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="run/1">
    <span class="signature"><strong>run(stream)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#run/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>run(<a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: :ok</li>
      
    </ul>
  
  <section class="docstring">
    <p>Runs the given stream.</p>
<p>This is useful when a stream needs to be run, for side effects,
and there is no interest in its return result.</p>
<h2>Examples</h2>
<p>Open up a file, replace all <code class="inline">#</code> by <code class="inline">%</code> and stream to another file
without loading the whole file in memory:</p>
<pre><code>stream = File.stream!(&quot;code&quot;)
|&gt; Stream.map(&amp;String.replace(&amp;1, &quot;#&quot;, &quot;%&quot;))
|&gt; Stream.into(File.stream!(&quot;new&quot;))
|&gt; Stream.run</code></pre>
<p>No computation will be done until we call one of the Enum functions
or <a href="Stream.html#run/1"><code class="inline">Stream.run/1</code></a>.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L454" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="scan/2">
    <span class="signature"><strong>scan(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#scan/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>scan(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a>, <a href="#t:acc/0">acc</a> -> any)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.scan(1..5, &amp;(&amp;1 + &amp;2))
iex&gt; Enum.to_list(stream)
[1,3,6,10,15]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L472" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="scan/3">
    <span class="signature"><strong>scan(enum, acc, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#scan/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>scan(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, <a href="#t:acc/0">acc</a>, (<a href="#t:element/0">element</a>, <a href="#t:acc/0">acc</a> -> any)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that applies the given function to each
element, emits the result and uses the same result as the accumulator
for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
iex&gt; Enum.to_list(stream)
[1,3,6,10,15]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L489" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="take/2">
    <span class="signature"><strong>take(enum, n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#take/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Lazily takes the next <code class="inline">n</code> items from the enumerable and stops
enumeration.</p>
<p>If a negative <code class="inline">n</code> is given, the last <code class="inline">n</code> values will be taken.
For such, the collection is fully enumerated keeping up to <code class="inline">2 * n</code>
elements in memory. Once the end of the collection is reached,
the last <code class="inline">count</code> elements will be executed. Therefore, using
a negative <code class="inline">n</code> on an infinite collection will never return.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.take(1..100, 5)
iex&gt; Enum.to_list(stream)
[1,2,3,4,5]

iex&gt; stream = Stream.take(1..100, -5)
iex&gt; Enum.to_list(stream)
[96,97,98,99,100]

iex&gt; stream = Stream.cycle([1, 2, 3]) |&gt; Stream.take(5)
iex&gt; Enum.to_list(stream)
[1,2,3,1,2]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L519" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="take_every/2">
    <span class="signature"><strong>take_every(enum, n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#take_every/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take_every(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, non_neg_integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that takes every <code class="inline">n</code> item from the enumerable.</p>
<p>The first item is always included, unless <code class="inline">n</code> is 0.</p>
<p><code class="inline">n</code> must be a non-negative integer, or <a href="FunctionClauseError.html"><code class="inline">FunctionClauseError</code></a> will be thrown.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.take_every(1..10, 2)
iex&gt; Enum.to_list(stream)
[1,3,5,7,9]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L570" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="take_while/2">
    <span class="signature"><strong>take_while(enum, fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#take_while/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take_while(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Lazily takes elements of the enumerable while the given
function returns <code class="inline">true</code>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.take_while(1..100, &amp;(&amp;1 &lt;= 5))
iex&gt; Enum.to_list(stream)
[1,2,3,4,5]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L588" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="timer/1">
    <span class="signature"><strong>timer(n)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#timer/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>timer(non_neg_integer) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that emits a single value after <code class="inline">n</code> milliseconds.</p>
<p>The value emitted is <code class="inline">0</code>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.timer(10) |&gt; Enum.to_list
[0]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L604" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="transform/3">
    <span class="signature"><strong>transform(enum, acc, reducer)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#transform/3" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>transform(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, acc, fun) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a> when fun: (<a href="#t:element/0">element</a>, acc -> {<a href="Enumerable.html#t:t/0">Enumerable.t</a>, acc} | {:halt, acc}), acc: any</li>
      
    </ul>
  
  <section class="docstring">
    <p>Transforms an existing stream.</p>
<p>It expects an accumulator and a function that receives each stream item
and an accumulator, and must return a tuple containing a new stream
(often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first
element and the accumulator as second.</p>
<p>Note: this function is similar to <a href="Enum.html#flat_map_reduce/3"><code class="inline">Enum.flat_map_reduce/3</code></a> except the
latter returns both the flat list and accumulator, while this one returns
only the stream.</p>
<h2>Examples</h2>
<p><a href="Stream.html#transform/3"><code class="inline">Stream.transform/3</code></a> is useful as it can be used as the basis to implement
many of the functions defined in this module. For example, we can implement
<code class="inline">Stream.take(enum, n)</code> as follows:</p>
<pre><code>iex&gt; enum = 1..100
iex&gt; n = 3
iex&gt; stream = Stream.transform(enum, 0, fn i, acc -&gt;
...&gt;   if acc &lt; n, do: {[i], acc + 1}, else: {:halt, acc}
...&gt; end)
iex&gt; Enum.to_list(stream)
[1,2,3]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L638" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="unfold/2">
    <span class="signature"><strong>unfold(next_acc, next_fun)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#unfold/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>unfold(<a href="#t:acc/0">acc</a>, (<a href="#t:acc/0">acc</a> -> {<a href="#t:element/0">element</a>, <a href="#t:acc/0">acc</a>} | nil)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Emits a sequence of values for the given accumulator.</p>
<p>Successive values are generated by calling <code class="inline">next_fun</code> with the previous
accumulator and it must return a tuple with the current value and next
accumulator. The enumeration finishes if it returns <code class="inline">nil</code>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.unfold(5, fn 0 -&gt; nil; n -&gt; {n, n-1} end) |&gt; Enum.to_list()
[5, 4, 3, 2, 1]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L1114" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="uniq/2">
    <span class="signature"><strong>uniq(enum, fun \\ fn x -&gt; x end)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#uniq/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>uniq(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, (<a href="#t:element/0">element</a> -> term)) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream that only emits elements if they are unique.</p>
<p>Keep in mind that, in order to know if an element is unique
or not, this function needs to store all unique values emitted
by the stream. Therefore, if the stream is infinite, the number
of items stored will grow infinitely, never being garbage collected.</p>
<h2>Examples</h2>
<pre><code>iex&gt; Stream.uniq([1, 2, 3, 2, 1]) |&gt; Enum.to_list
[1, 2, 3]

iex&gt; Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end) |&gt; Enum.to_list
[{1,:x}, {2,:y}]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L747" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="with_index/1">
    <span class="signature"><strong>with_index(enum)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#with_index/1" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>with_index(<a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Creates a stream where each item in the enumerable will
be wrapped in a tuple alongside its index.</p>
<h2>Examples</h2>
<pre><code>iex&gt; stream = Stream.with_index([1, 2, 3])
iex&gt; Enum.to_list(stream)
[{1,0},{2,1},{3,2}]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L763" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="zip/2">
    <span class="signature"><strong>zip(left, right)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(function)</span>
      <a href="#zip/2" class="detail_link" title="Link to this function">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>zip(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, <a href="Enumerable.html#t:t/0">Enumerable.t</a>) :: <a href="Enumerable.html#t:t/0">Enumerable.t</a></li>
      
    </ul>
  
  <section class="docstring">
    <p>Zips two collections together, lazily.</p>
<p>The zipping finishes as soon as any enumerable completes.</p>
<h2>Examples</h2>
<pre><code>iex&gt; concat = Stream.concat(1..3, 4..6)
iex&gt; cycle  = Stream.cycle([:a, :b, :c])
iex&gt; Stream.zip(concat, cycle) |&gt; Enum.to_list
[{1,:a},{2,:b},{3,:c},{4,:a},{5,:b},{6,:c}]</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/ebc5afed90576a16c4f6e22d68222413db8358cc/lib/elixir/lib/stream.ex#L819" class="view_source">Source</a>
  
</section>

        </section>
      

      

      
    </section>
  </body>
</html>
