<!DOCTYPE html>
<html>
  <head>
    <title>Kernel.SpecialForms</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="css/elixir.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <section id="content">
      <div class="breadcrumbs">Elixir v1.1.0-dev &rarr; <a href="overview.html">Overview</a> &rarr; <a href="Kernel.html">Kernel</a> &rarr; <a href="Kernel.SpecialForms.html">SpecialForms</a></div>
      <h1>
        Kernel.SpecialForms
        
      </h1>

      <ul class="summary_links">
        
          <li><a href="#summary">Summary</a></li>
        
        
        
        
          <li><a href="#macros_details">Macros</a></li>
        
        
      </ul>

      
        <section id="moduledoc" class="docstring">
          <p>In this module we define Elixir special forms. Special forms
cannot be overridden by the developer and are the basic
building blocks of Elixir code.</p>
<p>Some of those forms are lexical (like <code class="inline">alias</code>, <code class="inline">case</code>, etc).
The macros <code class="inline">{}</code> and <code class="inline">&lt;&lt;&gt;&gt;</code> are also special forms used to define
tuple and binary data structures respectively.</p>
<p>This module also documents Elixir’s pseudo variables (<code class="inline">__ENV__</code>,
<code class="inline">__MODULE__</code>, <code class="inline">__DIR__</code> and <code class="inline">__CALLER__</code>). Pseudo variables return
information about Elixir’s compilation environment and can only
be read, never assigned to.</p>
<p>Finally, it also documents 2 special forms, <code class="inline">__block__</code> and
<code class="inline">__aliases__</code>, which are not intended to be called directly by the
developer but they appear in quoted contents since they are essential
in Elixir’s constructs.</p>

        </section>
      

      
        <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1" class="view_source">Source</a>
      

      
        <h2 id="summary">Summary<span class="detail_header_links"><a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></span></h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#%/2">%</a></td>
  
    <td class="summary_synopsis"><p>Creates a struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#%{}/1">%{}</a></td>
  
    <td class="summary_synopsis"><p>Creates a map</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&amp;/1">&amp;expr</a></td>
  
    <td class="summary_synopsis"><p>Captures or creates an anonymous function</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#./2">left . right</a></td>
  
    <td class="summary_synopsis"><p>Defines a remote call or an alias</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;&lt;&gt;&gt;/1">&lt;&lt;args&gt;&gt;</a></td>
  
    <td class="summary_synopsis"><p>Defines a new bitstring</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#^/1">^var</a></td>
  
    <td class="summary_synopsis"><p>Accesses an already bound variable in match clauses</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__CALLER__/0">__CALLER__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current calling environment as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__DIR__/0">__DIR__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current directory as a binary</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__ENV__/0">__ENV__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current environment information as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__MODULE__/0">__MODULE__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__aliases__/1">__aliases__(args)</a></td>
  
    <td class="summary_synopsis"><p>Internal special form to hold aliases information</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__block__/1">__block__(args)</a></td>
  
    <td class="summary_synopsis"><p>Internal special form for block expressions</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#alias/2">alias(module, opts)</a></td>
  
    <td class="summary_synopsis"><p><code class="inline">alias</code> is used to setup aliases, often useful with modules names</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#case/2">case(condition, clauses)</a></td>
  
    <td class="summary_synopsis"><p>Matches the given expression against the given clauses</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#cond/1">cond(clauses)</a></td>
  
    <td class="summary_synopsis"><p>Evaluates the expression corresponding to the first clause that
evaluates to truth value</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#fn/1">fn
  [clauses]
end</a></td>
  
    <td class="summary_synopsis"><p>Defines an anonymous function</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#for/1">for(args)</a></td>
  
    <td class="summary_synopsis"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#import/2">import(module, opts)</a></td>
  
    <td class="summary_synopsis"><p>Imports function and macros from other modules</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#quote/2">quote(opts, block)</a></td>
  
    <td class="summary_synopsis"><p>Gets the representation of any expression</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#receive/1">receive(args)</a></td>
  
    <td class="summary_synopsis"><p>Checks if there is a message matching the given clauses
in the current process mailbox</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#require/2">require(module, opts)</a></td>
  
    <td class="summary_synopsis"><p>Requires a given module to be compiled and loaded</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#super/1">super(args)</a></td>
  
    <td class="summary_synopsis"><p>Calls the overriden function when overriding it with <code class="inline">defoverridable</code>.
See <code class="inline">Kernel.defoverridable</code> for more information and documentation</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#try/1">try(args)</a></td>
  
    <td class="summary_synopsis"><p>Evaluates the given expressions and handle any error, exit
or throw that may have happened</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unquote/1">unquote(expr)</a></td>
  
    <td class="summary_synopsis"><p>Unquotes the given expression from inside a macro</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unquote_splicing/1">unquote_splicing(expr)</a></td>
  
    <td class="summary_synopsis"><p>Unquotes the given list expanding its arguments. Similar
to unquote</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#{}/1">{args}</a></td>
  
    <td class="summary_synopsis"><p>Creates a tuple</p>
</td>
  
</tr>

        </table>
      

      

      

      
        <section id="macros_details" class="details_list">
          <h2>Macros</h2>
          <section class="detail">
  <div class="detail_header" id="%/2">
    <span class="signature"><strong>%</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#%/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Creates a struct.</p>
<p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p>
<p>To define a struct, you just need to implement the <code class="inline">__struct__/0</code>
function in a module:</p>
<pre><code>defmodule User do
  def __struct__ do
    %{name: &quot;john&quot;, age: 27}
  end
end</code></pre>
<p>In practice though, structs are usually defined with the
<a href="Kernel.html#defstruct/1"><code class="inline">Kernel.defstruct/1</code></a> macro:</p>
<pre><code>defmodule User do
  defstruct name: &quot;john&quot;, age: 27
end</code></pre>
<p>Now a struct can be created as follows:</p>
<pre><code>%User{}</code></pre>
<p>Underneath a struct is just a map with a <code class="inline">__struct__</code> field
pointing to the <code class="inline">User</code> module:</p>
<pre><code>%User{} == %{__struct__: User, name: &quot;john&quot;, age: 27}</code></pre>
<p>A struct also validates that the given keys are part of the defined
struct. The example below will fail because there is no key
<code class="inline">:full_name</code> in the <code class="inline">User</code> struct:</p>
<pre><code>%User{full_name: &quot;john doe&quot;}</code></pre>
<p>Note that a struct specifies a minimum set of keys required
for operations. Other keys can be added to structs via the
regular map operations:</p>
<pre><code>user = %User{}
Map.put(user, :a_non_struct_key, :value)</code></pre>
<p>An update operation specific for structs is also available:</p>
<pre><code>%User{user | age: 28}</code></pre>
<p>The syntax above will guarantee the given keys are valid at
compilation time and it will guarantee at runtime the given
argument is a struct, failing with <a href="BadStructError.html"><code class="inline">BadStructError</code></a> otherwise.</p>
<p>Although structs are maps, by default structs do not implement
any of the protocols implemented for maps. Check
<a href="Kernel.html#defprotocol/2"><code class="inline">Kernel.defprotocol/2</code></a> for more information on how structs
can be used with protocols for polymorphic dispatch. Also
see <a href="Kernel.html#struct/2"><code class="inline">Kernel.struct/2</code></a> for examples on how to create and update
structs dynamically.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L165" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="%{}/1">
    <span class="signature"><strong>%{}</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#%{}/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Creates a map.</p>
<p>Maps are key-value stores where keys are compared
using the match operator (<code class="inline">===</code>). Maps can be created with
the <code class="inline">%{}</code> special form where keys are associated via <code class="inline">=&gt;</code>:</p>
<pre><code>%{1 =&gt; 2}</code></pre>
<p>Maps also support the keyword notation, as other special forms,
as long as they are at the end of the argument list:</p>
<pre><code>%{hello: :world, with: :keywords}
%{:hello =&gt; :world, with: :keywords}</code></pre>
<p>If a map has duplicated keys, the last key will always have
higher precedence:</p>
<pre><code>iex&gt; %{a: :b, a: :c}
%{a: :c}</code></pre>
<p>Conveniences for manipulating maps can be found in the
<a href="Map.html"><code class="inline">Map</code></a> module.</p>
<h2>Access syntax</h2>
<p>Besides the access functions available in the <a href="Map.html"><code class="inline">Map</code></a> module,
like <a href="Map.html#get/3"><code class="inline">Map.get/3</code></a> and <a href="Map.html#fetch/2"><code class="inline">Map.fetch/2</code></a>, a map can be accessed using the
<code class="inline">.</code> operator:</p>
<pre><code>iex&gt; map = %{a: :b}
iex&gt; map.a
:b</code></pre>
<p>Note that the <code class="inline">.</code> operator expects the field to exist in the map.
If not, an <a href="ArgumentError.html"><code class="inline">ArgumentError</code></a> is raised.</p>
<h2>Update syntax</h2>
<p>Maps also support an update syntax:</p>
<pre><code>iex&gt; map = %{:a =&gt; :b}
iex&gt; %{map | :a =&gt; :c}
%{:a =&gt; :c}</code></pre>
<p>Notice the update syntax requires the given keys to exist.
Trying to update a key that does not exist will raise an <a href="ArgumentError.html"><code class="inline">ArgumentError</code></a>.</p>
<h2>AST representation</h2>
<p>Regardless if <code class="inline">=&gt;</code> or the keywords syntax is used, Maps are
always represented internally as a list of two-items tuples
for simplicity:</p>
<pre><code>iex&gt; quote do: %{:a =&gt; :b, c: :d}
{:%{}, [], [{:a, :b}, {:c, :d}]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L103" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="&amp;/1">
    <span class="signature"><strong>&amp;expr</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#&amp;/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Captures or creates an anonymous function.</p>
<h2>Capture</h2>
<p>The capture operator is most commonly used to capture a
function with given name and arity from a module:</p>
<pre><code>iex&gt; fun = &amp;Kernel.is_atom/1
iex&gt; fun.(:atom)
true
iex&gt; fun.(&quot;string&quot;)
false</code></pre>
<p>In the example above, we captured <a href="Kernel.html#is_atom/1"><code class="inline">Kernel.is_atom/1</code></a> as an
anonymous function and then invoked it.</p>
<p>The capture operator can also be used to capture local functions,
including private ones, and imported functions by omitting the
module name:</p>
<pre><code>&amp;local_function/1</code></pre>
<h2>Anonymous functions</h2>
<p>The capture operator can also be used to partially apply
functions, where <code class="inline">&amp;1</code>, <code class="inline">&amp;2</code> and so on can be used as value
placeholders. For example:</p>
<pre><code>iex&gt; double = &amp;(&amp;1 * 2)
iex&gt; double.(2)
4</code></pre>
<p>In other words, <code class="inline">&amp;(&amp;1 * 2)</code> is equivalent to <code class="inline">fn x -&gt; x * 2 end</code>.
Another example using a local function:</p>
<pre><code>iex&gt; fun = &amp;is_atom(&amp;1)
iex&gt; fun.(:atom)
true</code></pre>
<p>The <code class="inline">&amp;</code> operator can be used with more complex expressions:</p>
<pre><code>iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)
iex&gt; fun.(1, 2, 3)
6</code></pre>
<p>As well as with lists and tuples:</p>
<pre><code>iex&gt; fun = &amp;{&amp;1, &amp;2}
iex&gt; fun.(1, 2)
{1, 2}

iex&gt; fun = &amp;[&amp;1|&amp;2]
iex&gt; fun.(1, 2)
[1|2]</code></pre>
<p>The only restrictions when creating anonymous functions is that at
least one placeholder must be present, i.e. it must contain at least
<code class="inline">&amp;1</code>:</p>
<pre><code># No placeholder fails to compile
&amp;var

# Block expressions are also not supported
&amp;(foo(&amp;1, &amp;2); &amp;3 + &amp;4)</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1298" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="./2">
    <span class="signature"><strong>left . right</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#./2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Defines a remote call or an alias.</p>
<p>The dot (<code class="inline">.</code>) in Elixir can be used for remote calls:</p>
<pre><code>iex&gt; String.downcase(&quot;FOO&quot;)
&quot;foo&quot;</code></pre>
<p>In this example above, we have used <code class="inline">.</code> to invoke <code class="inline">downcase</code> in the
<a href="String.html"><code class="inline">String</code></a> alias, passing “FOO” as argument. We can also use the dot
for creating aliases:</p>
<pre><code>iex&gt; Hello.World
Hello.World</code></pre>
<p>This time, we have joined two aliases, defining the final alias
<code class="inline">Hello.World</code>.</p>
<h2>Syntax</h2>
<p>The right side of <code class="inline">.</code> may be a word starting in upcase, which represents
an alias, a word starting with lowercase or underscore, any valid language
operator or any name wrapped in single- or double-quotes. Those are all valid
examples:</p>
<pre><code>iex&gt; Kernel.Sample
Kernel.Sample

iex&gt; Kernel.length([1,2,3])
3

iex&gt; Kernel.+(1, 2)
3

iex&gt; Kernel.&quot;length&quot;([1,2,3])
3

iex&gt; Kernel.'+'(1, 2)
3</code></pre>
<p>Note that <code class="inline">Kernel.&quot;HELLO&quot;</code> will be treated as a remote call and not an alias.
This choice was done so every time single- or double-quotes are used, we have
a remote call regardless of the quote contents. This decision is also reflected
in the quoted expressions discussed below.</p>
<h2>Quoted expression</h2>
<p>When <code class="inline">.</code> is used, the quoted expression may take two distinct
forms. When the right side starts with a lowercase letter (or
underscore):</p>
<pre><code>iex&gt; quote do: String.downcase(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>Notice we have an inner tuple, containing the atom <code class="inline">:.</code> representing
the dot as first element:</p>
<pre><code>{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}</code></pre>
<p>This tuple follows the general quoted expression structure in Elixir,
with the name as first argument, some keyword list as metadata as second,
and the number of arguments as third. In this case, the arguments is the
alias <a href="String.html"><code class="inline">String</code></a> and the atom <code class="inline">:downcase</code>. The second argument is <strong>always</strong>
an atom:</p>
<pre><code>iex&gt; quote do: String.&quot;downcase&quot;(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>The tuple containing <code class="inline">:.</code> is wrapped in another tuple, which actually
represents the function call, and has <code class="inline">&quot;FOO&quot;</code> as argument.</p>
<p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p>
<pre><code>iex&gt; quote do: Hello.World
{:__aliases__, [alias: false], [:Hello, :World]}</code></pre>
<p>We got into more details about aliases in the <code class="inline">__aliases__</code> special form
documentation.</p>
<h2>Unquoting</h2>
<p>We can also use unquote to generate a remote call in a quoted expression:</p>
<pre><code>iex&gt; x = :downcase
iex&gt; quote do: String.unquote(x)(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>Similar to <code class="inline">Kernel.&quot;HELLO&quot;</code>, <code class="inline">unquote(x)</code> will always generate a remote call,
independent of the value of <code class="inline">x</code>. To generate an alias via the quoted expression,
one needs to rely on <a href="Module.html#concat/2"><code class="inline">Module.concat/2</code></a>:</p>
<pre><code>iex&gt; x = Sample
iex&gt; quote do: Module.concat(String, unquote(x))
{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],
 [{:__aliases__, [alias: false], [:String]}, Sample]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L410" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="&lt;&lt;&gt;&gt;/1">
    <span class="signature"><strong>&lt;&lt;args&gt;&gt;</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#&lt;&lt;&gt;&gt;/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Defines a new bitstring.</p>
<h2>Examples</h2>
<pre><code>iex&gt; &lt;&lt; 1, 2, 3 &gt;&gt;
&lt;&lt; 1, 2, 3 &gt;&gt;</code></pre>
<h2>Bitstring types</h2>
<p>A bitstring is made of many segments. Each segment has a
type, which defaults to integer:</p>
<pre><code>iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;</code></pre>
<p>Elixir also accepts by default the segment to be a literal
string or a literal char list, which are by expanded to integers:</p>
<pre><code>iex&gt; &lt;&lt;0, &quot;foo&quot;&gt;&gt;
&lt;&lt;0, 102, 111, 111&gt;&gt;</code></pre>
<p>Any other type needs to be explicitly tagged. For example,
in order to store a float type in the binary, one has to do:</p>
<pre><code>iex&gt; &lt;&lt;3.14 :: float&gt;&gt;
&lt;&lt;64, 9, 30, 184, 81, 235, 133, 31&gt;&gt;</code></pre>
<p>This also means that variables need to be explicitly tagged,
otherwise Elixir defaults to integer:</p>
<pre><code>iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error</code></pre>
<p>We can solve this by explicitly tagging it as a binary:</p>
<pre><code>&lt;&lt;102, rest :: binary&gt;&gt;</code></pre>
<p>The type can be integer, float, bitstring/bits, binary/bytes,
utf8, utf16 or utf32, e.g.:</p>
<pre><code>&lt;&lt;102 :: float, rest :: binary&gt;&gt;</code></pre>
<p>An integer can be any arbitrary precision integer. A float is an
IEEE 754 binary32 or binary64 floating point number. A bitstring
is an arbitrary series of bits. A binary is a special case of
bitstring that has a total size divisible by 8.</p>
<p>The utf8, utf16, and utf32 types are for unicode codepoints. They
can also be applied to literal strings and char lists:</p>
<pre><code>iex&gt; &lt;&lt;&quot;foo&quot; :: utf16&gt;&gt;
&lt;&lt;0,102,0,111,0,111&gt;&gt;</code></pre>
<p>The bits type is an alias for bitstring. The bytes type is an
alias for binary.</p>
<p>The signedness can also be given as signed or unsigned. The
signedness only matters for matching and relevant only for
integers. If unspecified, it defaults to unsigned. Example:</p>
<pre><code>iex&gt; &lt;&lt;-100 :: signed, _rest :: binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
&lt;&lt;156,102,111,111&gt;&gt;</code></pre>
<p>This match would have failed if we did not specify that the
value -100 is signed. If we’re matching into a variable instead
of a value, the signedness won’t be checked; rather, the number
will simply be interpreted as having the given (or implied)
signedness, e.g.:</p>
<pre><code>iex&gt; &lt;&lt;val, _rest :: binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
iex&gt; val
156</code></pre>
<p>Here, <code class="inline">val</code> is interpreted as unsigned.</p>
<p>The endianness of a segment can be big, little or native (the
latter meaning it will be resolved at VM load time).</p>
<p>Many options can be given by using <code class="inline">-</code> as separator, order is
arbitrary. The following are all the same:</p>
<pre><code>&lt;&lt;102 :: integer-native, rest :: binary&gt;&gt;
&lt;&lt;102 :: native-integer, rest :: binary&gt;&gt;  
&lt;&lt;102 :: unsigned-big-integer, rest :: binary&gt;&gt;
&lt;&lt;102 :: unsigned-big-integer-size(8), rest :: binary&gt;&gt;
&lt;&lt;102 :: unsigned-big-integer-8, rest :: binary&gt;&gt;
&lt;&lt;102 :: 8-integer-big-unsigned, rest :: binary&gt;&gt;
&lt;&lt;102, rest :: binary&gt;&gt;</code></pre>
<p>And so on.</p>
<p>Endianness only makes sense for integers and some UTF code
point types (utf16 and utf32).</p>
<p>Finally, we can also specify size and unit for each segment. The
unit is multiplied by the size to give the effective size of
the segment in bits. The default unit for integers, floats,
and bitstrings is 1. For binaries, it is 8.</p>
<p>Since integers are default, the default unit is 1. The example below
matches because the string “foo” takes 24 bits and we match it
against a segment of 24 bits, 8 of which are taken by the integer
102 and the remaining 16 bits are specified on the rest.</p>
<pre><code>iex&gt; &lt;&lt;102, _rest :: size(16)&gt;&gt; = &quot;foo&quot;
&quot;foo&quot;</code></pre>
<p>We can also match by specifying size and unit explicitly:</p>
<pre><code>iex&gt; &lt;&lt;102, _rest :: size(2)-unit(8)&gt;&gt; = &quot;foo&quot;
&quot;foo&quot;</code></pre>
<p>However, if we expect a size of 32, it won’t match:</p>
<pre><code>iex&gt; &lt;&lt;102, _rest :: size(32)&gt;&gt; = &quot;foo&quot;
** (MatchError) no match of right hand side value: &quot;foo&quot;</code></pre>
<p>Size and unit are not applicable to utf8, utf16, and utf32.</p>
<p>The default size for integers is 8. For floats, it is 64. For
binaries, it is the size of the binary. Only the last binary
in a binary match can use the default size (all others must
have their size specified explicitly).</p>
<pre><code>iex&gt; &lt;&lt;3.14 :: float&gt;&gt;
&lt;&lt;64, 9, 30, 184, 81, 235, 133, 31&gt;&gt;
iex&gt; &lt;&lt;3.14 :: float-32&gt;&gt;
&lt;&lt;64, 72, 245, 195&gt;&gt;</code></pre>
<p>Size and unit can also be specified using a syntax shortcut
when passing integer values:</p>
<pre><code>&lt;&lt; x :: 8 &gt;&gt; == &lt;&lt; x :: size(8) &gt;&gt;
&lt;&lt; x :: 8 * 4 &gt;&gt; == &lt;&lt; x :: size(8)-unit(4) &gt;&gt;
&lt;&lt; x :: _ * 4 &gt;&gt; == &lt;&lt; x :: unit(4) &gt;&gt;</code></pre>
<p>This syntax reflects the fact the effective size is given by
multiplying the size by the unit.</p>
<p>For floats, <code class="inline">size * unit</code> must result in 32 or 64, corresponding
to binary32 and binary64, respectively.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L311" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="^/1">
    <span class="signature"><strong>^var</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#^/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Accesses an already bound variable in match clauses.</p>
<h2>Examples</h2>
<p>Elixir allows variables to be rebound via static single assignment:</p>
<pre><code>iex&gt; x = 1
iex&gt; x = 2
iex&gt; x
2</code></pre>
<p>However, in some situations, it is useful to match against an existing
value, instead of rebinding. This can be done with the <code class="inline">^</code> special form:</p>
<pre><code>iex&gt; x = 1
iex&gt; ^x = List.first([1])
iex&gt; ^x = List.first([2])
** (MatchError) no match of right hand side value: 2</code></pre>
<p>Note that <code class="inline">^</code> always refers to the value of x prior to the match. The
following example will match:</p>
<pre><code>iex&gt; x = 0
iex&gt; {x, ^x} = {1, 0}
iex&gt; x
1</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L642" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__CALLER__/0">
    <span class="signature"><strong>__CALLER__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__CALLER__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Returns the current calling environment as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the filename, line numbers,
set up aliases, the function and others.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L611" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__DIR__/0">
    <span class="signature"><strong>__DIR__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__DIR__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Returns the current directory as a binary.</p>
<p>Although the directory can be accessed as <code class="inline">Path.dirname(__ENV__.file)</code>,
this macro is a convenient shortcut.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L603" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__ENV__/0">
    <span class="signature"><strong>__ENV__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__ENV__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Returns the current environment information as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L587" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__MODULE__/0">
    <span class="signature"><strong>__MODULE__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__MODULE__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p>
<p>Although the module can be accessed in the <code class="inline">__ENV__</code>, this macro
is a convenient shortcut.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L595" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__aliases__/1">
    <span class="signature"><strong>__aliases__(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__aliases__/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Internal special form to hold aliases information.</p>
<p>It is usually compiled to an atom:</p>
<pre><code>iex&gt; quote do: Foo.Bar
{:__aliases__, [alias: false], [:Foo, :Bar]}</code></pre>
<p>Elixir represents <code class="inline">Foo.Bar</code> as <code class="inline">__aliases__</code> so calls can be
unambiguously identified by the operator <code class="inline">:.</code>. For example:</p>
<pre><code>iex&gt; quote do: Foo.bar
{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}</code></pre>
<p>Whenever an expression iterator sees a <code class="inline">:.</code> as the tuple key,
it can be sure that it represents a call and the second argument
in the list is an atom.</p>
<p>On the other hand, aliases holds some properties:</p>
<p>  1. The head element of aliases can be any term that must expand to</p>
<pre><code>an atom at compilation time.</code></pre>
<p>  2. The tail elements of aliases are guaranteed to always be atoms.</p>
<p>  3. When the head element of aliases is the atom <code class="inline">:Elixir</code>, no expansion happen.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1328" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="__block__/1">
    <span class="signature"><strong>__block__(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__block__/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Internal special form for block expressions.</p>
<p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p>
<pre><code>iex&gt; quote do: (1; 2; 3)
{:__block__, [], [1, 2, 3]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1229" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="alias/2">
    <span class="signature"><strong>alias(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#alias/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p><code class="inline">alias</code> is used to setup aliases, often useful with modules names.</p>
<h2>Examples</h2>
<p><code class="inline">alias</code> can be used to setup an alias for any module:</p>
<pre><code>defmodule Math do
  alias MyKeyword, as: Keyword
end</code></pre>
<p>In the example above, we have set up <code class="inline">MyKeyword</code> to be aliased
as <a href="Keyword.html"><code class="inline">Keyword</code></a>. So now, any reference to <a href="Keyword.html"><code class="inline">Keyword</code></a> will be
automatically replaced by <code class="inline">MyKeyword</code>.</p>
<p>In case one wants to access the original <a href="Keyword.html"><code class="inline">Keyword</code></a>, it can be done
by accessing <code class="inline">Elixir</code>:</p>
<pre><code>Keyword.values   #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values</code></pre>
<p>Notice that calling <code class="inline">alias</code> without the <code class="inline">as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>
<pre><code>alias Foo.Bar.Baz</code></pre>
<p>Is the same as:</p>
<pre><code>alias Foo.Bar.Baz, as: Baz</code></pre>
<h2>Lexical scope</h2>
<p><code class="inline">import</code>, <code class="inline">require</code> and <code class="inline">alias</code> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won’t affect the overall scope.</p>
<h2>Warnings</h2>
<p>If you alias a module and you don’t use the alias, Elixir is
going to issue a warning implying the alias is not being used.</p>
<p>In case the alias is generated automatically by a macro,
Elixir won’t emit any warnings though, since the alias
was not explicitly defined.</p>
<p>Both warning behaviours could be changed by explicitly
setting the <code class="inline">:warn</code> option to true or false.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L460" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="case/2">
    <span class="signature"><strong>case(condition, clauses)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#case/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Matches the given expression against the given clauses.</p>
<h2>Examples</h2>
<pre><code>case thing do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value -&gt;
    value
end</code></pre>
<p>In the example above, we match <code class="inline">thing</code> against each clause “head”
and execute the clause “body” corresponding to the first clause
that matches. If no clause matches, an error is raised.</p>
<h2>Variables handling</h2>
<p>Notice that variables bound in a clause “head” do not leak to the
outer context:</p>
<pre><code>case data do
  {:ok, value} -&gt; value
  :error -&gt; nil
end

value #=&gt; unbound variable value</code></pre>
<p>However, variables explicitly bound in the clause “body” are
accessible from the outer context:</p>
<pre><code>value = 7

case lucky? do
  false -&gt; value = 13
  true  -&gt; true
end

value #=&gt; 7 or 13</code></pre>
<p>In the example above, value is going to be <code class="inline">7</code> or <code class="inline">13</code> depending on
the value of <code class="inline">lucky?</code>. In case <code class="inline">value</code> has no previous value before
case, clauses that do not explicitly bind a value have the variable
bound to nil.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1381" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="cond/1">
    <span class="signature"><strong>cond(clauses)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#cond/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Evaluates the expression corresponding to the first clause that
evaluates to truth value.</p>
<p>Raises an error if all conditions evaluate to to nil or false.</p>
<h2>Examples</h2>
<pre><code>cond do
  1 + 1 == 1 -&gt;
    &quot;This will never match&quot;
  2 * 2 != 4 -&gt;
    &quot;Nor this&quot;
  true -&gt;
    &quot;This will&quot;
end</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1401" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="fn/1">
    <span class="signature"><strong>fn
  [clauses]
end</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#fn/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Defines an anonymous function.</p>
<h2>Examples</h2>
<pre><code>iex&gt; add = fn a, b -&gt; a + b end
iex&gt; add.(1, 2)
3</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1216" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="for/1">
    <span class="signature"><strong>for(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#for/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p>
<p>Let’s start with an example:</p>
<pre><code>iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]</code></pre>
<p>A comprehension accepts many generators and filters. Enumerable
generators are defined using <code class="inline">&lt;-</code>:</p>
<pre><code># A list generator:
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]

# A comprehension with two generators
iex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x*y
[2, 3, 4, 6]</code></pre>
<p>Filters can also be given:</p>
<pre><code># A comprehension with a generator and a filter
iex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n
[2, 4, 6]</code></pre>
<p>Note generators can also be used to filter as it removes any value
that doesn’t match the left side of <code class="inline">&lt;-</code>:</p>
<pre><code>iex&gt; for {:user, name} &lt;- [user: &quot;john&quot;, admin: &quot;john&quot;, user: &quot;meg&quot;] do
...&gt;   String.upcase(name)
...&gt; end
[&quot;JOHN&quot;, &quot;MEG&quot;]</code></pre>
<p>Bitstring generators are also supported and are very useful when you
need to organize bitstring streams:</p>
<pre><code>iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels &gt;&gt;, do: {r, g, b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]</code></pre>
<p>Variable assignments inside the comprehension, be it in generators,
filters or inside the block, are not reflected outside of the
comprehension.</p>
<h2>Into</h2>
<p>In the examples above, the result returned by the comprehension was
always a list. The returned result can be configured by passing an
<code class="inline">:into</code> option, that accepts any structure as long as it implements
the <a href="Collectable.html"><code class="inline">Collectable</code></a> protocol.</p>
<p>For example, we can use bitstring generators with the <code class="inline">:into</code> option
to easily remove all spaces in a string:</p>
<pre><code>iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?\s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;</code></pre>
<p>The <a href="IO.html"><code class="inline">IO</code></a> module provides streams, that are both <a href="Enumerable.html"><code class="inline">Enumerable</code></a> and
<a href="Collectable.html"><code class="inline">Collectable</code></a>, here is an upcase echo server using comprehensions:</p>
<pre><code>for line &lt;- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do
  String.upcase(line)
end</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1204" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="import/2">
    <span class="signature"><strong>import(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#import/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Imports function and macros from other modules.</p>
<p><code class="inline">import</code> allows one to easily access functions or macros from
others modules without using the qualified name.</p>
<h2>Examples</h2>
<p>If you are using several functions from a given module, you can
import those functions and reference them as local functions,
for example:</p>
<pre><code>iex&gt; import List
iex&gt; flatten([1, [2], 3])
[1,2,3]</code></pre>
<h2>Selector</h2>
<p>By default, Elixir imports functions and macros from the given
module, except the ones starting with underscore (which are
usually callbacks):</p>
<pre><code>import List</code></pre>
<p>A developer can filter to import only macros or functions via
the only option:</p>
<pre><code>import List, only: :functions
import List, only: :macros</code></pre>
<p>Alternatively, Elixir allows a developer to pass pairs of
name/arities to <code class="inline">:only</code> or <code class="inline">:except</code> as a fine grained control
on what to import (or not):</p>
<pre><code>import List, only: [flatten: 1]
import String, except: [split: 2]</code></pre>
<p>Notice that calling <code class="inline">except</code> for a previously declared <code class="inline">import</code>
simply filters the previously imported elements. For example:</p>
<pre><code>import List, only: [flatten: 1, keyfind: 3]
import List, except: [flatten: 1]</code></pre>
<p>After the two import calls above, only <code class="inline">List.keyfind/3</code> will be
imported.</p>
<h2>Lexical scope</h2>
<p>It is important to notice that <code class="inline">import</code> is lexical. This means you
can import specific macros inside specific functions:</p>
<pre><code>defmodule Math do
  def some_function do
    # 1) Disable `if/2` from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new `if` macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end</code></pre>
<p>In the example above, we imported macros from <code class="inline">MyMacros</code>,
replacing the original <code class="inline">if/2</code> implementation by our own
within that specific function. All other functions in that
module will still be able to use the original one.</p>
<h2>Warnings</h2>
<p>If you import a module and you don’t use any of the imported
functions or macros from this module, Elixir is going to issue
a warning implying the import is not being used.</p>
<p>In case the import is generated automatically by a macro,
Elixir won’t emit any warnings though, since the import
was not explicitly defined.</p>
<p>Both warning behaviours could be changed by explicitly
setting the <code class="inline">:warn</code> option to true or false.</p>
<h2>Ambiguous function/macro names</h2>
<p>If two modules <code class="inline">A</code> and <code class="inline">B</code> are imported and they both contain
a <code class="inline">foo</code> function with an arity of <code class="inline">1</code>, an error is only emitted
if an ambiguous call to <code class="inline">foo/1</code> is actually made; that is, the
errors are emitted lazily, not eagerly.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L579" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="quote/2">
    <span class="signature"><strong>quote(opts, block)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#quote/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Gets the representation of any expression.</p>
<h2>Examples</h2>
<pre><code>quote do: sum(1, 2, 3)
#=&gt; {:sum, [], [1, 2, 3]}</code></pre>
<h2>Explanation</h2>
<p>Any Elixir code can be represented using Elixir data structures.
The building block of Elixir macros is a tuple with three elements,
for example:</p>
<pre><code>{:sum, [], [1, 2, 3]}</code></pre>
<p>The tuple above represents a function call to <code class="inline">sum</code> passing 1, 2 and
3 as arguments. The tuple elements are:</p>
<ul>
<li><p>The first element of the tuple is always an atom or
another tuple in the same representation.</p>
</li>
<li><p>The second element of the tuple represents metadata.</p>
</li>
<li>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, which is
usually a variable (or a local call).
</li>
</ul>
<h2>Options</h2>
<ul>
<li><p><code class="inline">:unquote</code> - when false, disables unquoting. Useful when you have a quote
inside another quote and want to control what quote is able to unquote.</p>
</li>
<li><p><code class="inline">:location</code> - when set to <code class="inline">:keep</code>, keeps the current line and file from
quote. Read the Stacktrace information section below for more
information.</p>
</li>
<li><p><code class="inline">:context</code> - sets the resolution context.</p>
</li>
<li><code class="inline">:bind_quoted</code> - passes a binding to the macro. Whenever a binding is
given, <code class="inline">unquote</code> is automatically disabled.
</li>
</ul>
<h2>Quote literals</h2>
<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>
<pre><code>:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1, 2]       #=&gt; Lists
&quot;strings&quot;    #=&gt; Strings
{key, value} #=&gt; Tuples with two elements</code></pre>
<h2>Quote and macros</h2>
<p><code class="inline">quote</code> is commonly used with macros for code generation. As an exercise,
let’s define a macro that multiplies a number by itself (squared). Note
there is no reason to define such as a macro (and it would actually be
seen as a bad practice), but it is simple enough that it allows us to focus
on the important aspects of quotes and macros:</p>
<pre><code>defmodule Math do
  defmacro squared(x) do
    quote do
      unquote(x) * unquote(x)
    end
  end
end</code></pre>
<p>We can invoke it as:</p>
<pre><code>import Math
IO.puts &quot;Got #{squared(5)}&quot;</code></pre>
<p>At first, there is nothing in this example that actually reveals it is a
macro. But what is happening is that, at compilation time, <code class="inline">squared(5)</code>
becomes <code class="inline">5 * 5</code>. The argument <code class="inline">5</code> is duplicated in the produced code, we
can see this behaviour in practice though because our macro actually has
a bug:</p>
<pre><code>import Math
my_number = fn -&gt;
  IO.puts &quot;Returning 5&quot;
  5
end
IO.puts &quot;Got #{squared(my_number.())}&quot;</code></pre>
<p>The example above will print:</p>
<pre><code>Returning 5
Returning 5
25</code></pre>
<p>Notice how “Returning 5” was printed twice, instead of just once. This is
because a macro receives an expression and not a value (which is what we
would expect in a regular function). This means that:</p>
<pre><code>squared(my_number.())</code></pre>
<p>Actually expands to:</p>
<pre><code>my_number.() * my_number.()</code></pre>
<p>Which invokes the function twice, explaining why we get the printed value
twice! In the majority of the cases, this is actually unexpected behaviour,
and that’s why one of the first things you need to keep in mind when it
comes to macros is to <strong>not unquote the same value more than once</strong>.</p>
<p>Let’s fix our macro:</p>
<pre><code>defmodule Math do
  defmacro squared(x) do
    quote do
      x = unquote(x)
      x * x
    end
  end
end</code></pre>
<p>Now invoking <code class="inline">square(my_number.())</code> as before will print the value just
once.</p>
<p>In fact, this pattern is so common that most of the times you will want
to use the <code class="inline">bind_quoted</code> option with <code class="inline">quote</code>:</p>
<pre><code>defmodule Math do
  defmacro squared(x) do
    quote bind_quoted: [x: x] do
      x * x
    end
  end
end</code></pre>
<p><code class="inline">:bind_quoted</code> will translate to the same code as the example above.
<code class="inline">:bind_quoted</code> can be used in many cases and is seen as good practice,
not only because it helps us from running into common mistakes but also
because it allows us to leverage other tools exposed by macros, such as
unquote fragments discussed in some sections below.</p>
<p>Before we finish this brief introduction, you will notice that, even though
we defined a variable <code class="inline">x</code> inside our quote:</p>
<pre><code>quote do
  x = unquote(x)
  x * x
end</code></pre>
<p>When we call:</p>
<pre><code>import Math
squared(5)
x #=&gt; ** (RuntimeError) undefined function or variable: x</code></pre>
<p>We can see that <code class="inline">x</code> did not leak to the user context. This happens
because Elixir macros are hygienic, a topic we will discuss at length
in the next sections as well.</p>
<h2>Hygiene in variables</h2>
<p>Consider the following example:</p>
<pre><code>defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10</code></pre>
<p>In the example above, <code class="inline">a</code> returns 10 even if the macro
is apparently setting it to 1 because variables defined
in the macro does not affect the context the macro is executed in.
If you want to set or get a variable in the caller’s context, you
can do it with the help of the <code class="inline">var!</code> macro:</p>
<pre><code>defmodule NoHygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 1</code></pre>
<p>Note that you cannot even access variables defined in the same
module unless you explicitly give it a context:</p>
<pre><code>defmodule Hygiene do
  defmacro write do
    quote do
      a = 1
    end
  end

  defmacro read do
    quote do
      a
    end
  end
end

Hygiene.write
Hygiene.read
#=&gt; ** (RuntimeError) undefined function or variable: a</code></pre>
<p>For such, you can explicitly pass the current module scope as
argument:</p>
<pre><code>defmodule ContextHygiene do
  defmacro write do
    quote do
      var!(a, ContextHygiene) = 1
    end
  end

  defmacro read do
    quote do
      var!(a, ContextHygiene)
    end
  end
end

ContextHygiene.write
ContextHygiene.read
#=&gt; 1</code></pre>
<h2>Hygiene in aliases</h2>
<p>Aliases inside quote are hygienic by default.
Consider the following example:</p>
<pre><code>defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;</code></pre>
<p>Notice that, even though the alias <code class="inline">D</code> is not available
in the context the macro is expanded, the code above works
because <code class="inline">D</code> still expands to <a href="HashDict.html"><code class="inline">HashDict</code></a>.</p>
<p>Similarly, even if we defined an alias with the same name
before invoking a macro, it won’t affect the macro’s result:</p>
<pre><code>defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
alias SomethingElse, as: D
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;</code></pre>
<p>In some cases, you want to access an alias or a module defined
in the caller. For such, you can use the <code class="inline">alias!</code> macro:</p>
<pre><code>defmodule Hygiene do
  # This will expand to Elixir.Nested.hello
  defmacro no_interference do
    quote do: Nested.hello
  end

  # This will expand to Nested.hello for
  # whatever is Nested in the caller
  defmacro interference do
    quote do: alias!(Nested).hello
  end
end

defmodule Parent do
  defmodule Nested do
    def hello, do: &quot;world&quot;
  end

  require Hygiene
  Hygiene.no_interference
  #=&gt; ** (UndefinedFunctionError) ...

  Hygiene.interference
  #=&gt; &quot;world&quot;
end</code></pre>
<h2>Hygiene in imports</h2>
<p>Similar to aliases, imports in Elixir are hygienic. Consider the
following code:</p>
<pre><code>defmodule Hygiene do
  defmacrop get_size do
    quote do
      size(&quot;hello&quot;)
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    get_size
  end
end

Hygiene.return_size #=&gt; 5</code></pre>
<p>Notice how <code class="inline">return_size</code> returns 5 even though the <code class="inline">size/1</code>
function is not imported. In fact, even if <code class="inline">return_size</code> imported
a function from another module, it wouldn’t affect the function
result:</p>
<pre><code>def return_size do
  import Dict, only: [size: 1]
  get_size
end</code></pre>
<p>Calling this new <code class="inline">return_size</code> will still return 5 as result.</p>
<p>Elixir is smart enough to delay the resolution to the latest
moment possible. So, if you call <code class="inline">size(&quot;hello&quot;)</code> inside quote,
but no <code class="inline">size/1</code> function is available, it is then expanded in
the caller:</p>
<pre><code>defmodule Lazy do
  defmacrop get_size do
    import Kernel, except: [size: 1]

    quote do
      size([a: 1, b: 2])
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    import Dict, only: [size: 1]
    get_size
  end
end

Lazy.return_size #=&gt; 2</code></pre>
<h2>Stacktrace information</h2>
<p>When defining functions via macros, developers have the option of
choosing if runtime errors will be reported from the caller or from
inside the quote. Let’s see an example:</p>
<pre><code># adder.ex
defmodule Adder do
  @doc &quot;Defines a function that adds two numbers&quot;
  defmacro defadd do
    quote location: :keep do
      def add(a, b), do: a + b
    end
  end
end

# sample.ex
defmodule Sample do
  import Adder
  defadd
end</code></pre>
<p>When using <code class="inline">location: :keep</code> and invalid arguments are given to
<code class="inline">Sample.add/2</code>, the stacktrace information will point to the file
and line inside the quote. Without <code class="inline">location: :keep</code>, the error is
reported to where <code class="inline">defadd</code> was invoked. Note <code class="inline">location: :keep</code> affects
only definitions inside the quote.</p>
<h2>Binding and unquote fragments</h2>
<p>Elixir quote/unquote mechanisms provides a functionality called
unquote fragments. Unquote fragments provide an easy way to generate
functions on the fly. Consider this example:</p>
<pre><code>kv = [foo: 1, bar: 2]
Enum.each kv, fn {k, v} -&gt;
  def unquote(k)(), do: unquote(v)
end</code></pre>
<p>In the example above, we have generated the functions <code class="inline">foo/0</code> and
<code class="inline">bar/0</code> dynamically. Now, imagine that, we want to convert this
functionality into a macro:</p>
<pre><code>defmacro defkv(kv) do
  Enum.map kv, fn {k, v} -&gt;
    quote do
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>We can invoke this macro as:</p>
<pre><code>defkv [foo: 1, bar: 2]</code></pre>
<p>However, we can’t invoke it as follows:</p>
<pre><code>kv = [foo: 1, bar: 2]
defkv kv</code></pre>
<p>This is because the macro is expecting its arguments to be a
keyword list at <strong>compilation</strong> time. Since in the example above
we are passing the representation of the variable <code class="inline">kv</code>, our
code fails.</p>
<p>This is actually a common pitfall when developing macros. We are
assuming a particular shape in the macro. We can work around it
by unquoting the variable inside the quoted expression:</p>
<pre><code>defmacro defkv(kv) do
  quote do
    Enum.each unquote(kv), fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>If you try to run our new macro, you will notice it won’t
even compile, complaining that the variables <code class="inline">k</code> and <code class="inline">v</code>
does not exist. This is because of the ambiguity: <code class="inline">unquote(k)</code>
can either be an unquote fragment, as previously, or a regular
unquote as in <code class="inline">unquote(kv)</code>.</p>
<p>One solution to this problem is to disable unquoting in the
macro, however, doing that would make it impossible to inject the
<code class="inline">kv</code> representation into the tree. That’s when the <code class="inline">:bind_quoted</code>
option comes to the rescue (again!). By using <code class="inline">:bind_quoted</code>, we
can automatically disable unquoting while still injecting the
desired variables into the tree:</p>
<pre><code>defmacro defkv(kv) do
  quote bind_quoted: [kv: kv] do
    Enum.each kv, fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>In fact, the <code class="inline">:bind_quoted</code> option is recommended every time
one desires to inject a value into the quote.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1098" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="receive/1">
    <span class="signature"><strong>receive(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#receive/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Checks if there is a message matching the given clauses
in the current process mailbox.</p>
<p>In case there is no such message, the current process hangs
until a message arrives or waits until a given timeout value.</p>
<h2>Examples</h2>
<pre><code>receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
end</code></pre>
<p>An optional after clause can be given in case the message was not
received after the specified period of time:</p>
<pre><code>receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
after
  5000 -&gt;
    IO.puts :stderr, &quot;No message in 5 seconds&quot;
end</code></pre>
<p>The <code class="inline">after</code> clause can be specified even if there are no match clauses.
There are two special cases for the timeout value given to <code class="inline">after</code></p>
<ul>
<li><p><code class="inline">:infinity</code> - the process should wait indefinitely for a matching
message, this is the same as not using a timeout</p>
</li>
<li>0 - if there is no matching message in the mailbox, the timeout
will occur immediately
</li>
</ul>
<h2>Variables handling</h2>
<p>The <code class="inline">receive</code> special form handles variables exactly as the <code class="inline">case</code>
special macro. For more information, check the docs for <a href="#case/2"><code class="inline">case/2</code></a>.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1671" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="require/2">
    <span class="signature"><strong>require(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#require/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Requires a given module to be compiled and loaded.</p>
<h2>Examples</h2>
<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>
<p>Let’s suppose you created your own <code class="inline">if</code> implementation in the module
<code class="inline">MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code class="inline">MyMacros</code>:</p>
<pre><code>defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end</code></pre>
<p>An attempt to call a macro that was not loaded will raise an error.</p>
<h2>Alias shortcut</h2>
<p><code class="inline">require</code> also accepts <code class="inline">as:</code> as an option so it automatically sets
up an alias. Please check <code class="inline">alias</code> for more information.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L488" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="super/1">
    <span class="signature"><strong>super(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#super/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Calls the overriden function when overriding it with <code class="inline">defoverridable</code>.
See <code class="inline">Kernel.defoverridable</code> for more information and documentation.</p>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1334" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="try/1">
    <span class="signature"><strong>try(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#try/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Evaluates the given expressions and handle any error, exit
or throw that may have happened.</p>
<h2>Examples</h2>
<pre><code>try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts &quot;Invalid argument given&quot;
catch
  value -&gt;
    IO.puts &quot;caught #{value}&quot;
else
  value -&gt;
    IO.puts &quot;Success! The result was #{value}&quot;
after
  IO.puts &quot;This is printed regardless if it failed or succeed&quot;
end</code></pre>
<p>The rescue clause is used to handle exceptions, while the catch
clause can be used to catch thrown values. The else clause can
be used to control flow based on the result of the expression.
Catch, rescue and else clauses work based on pattern matching.</p>
<p>Note that calls inside <code class="inline">try</code> are not tail recursive since the VM
needs to keep the stacktrace in case an exception happens.</p>
<h2>Rescue clauses</h2>
<p>Besides relying on pattern matching, rescue clauses provides some
conveniences around exceptions that allows one to rescue an
exception by its name. All the following formats are valid rescue
expressions:</p>
<pre><code>try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError] -&gt; nil
end

# rescue and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# rescue all and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end</code></pre>
<h2>Erlang errors</h2>
<p>Erlang errors are transformed into Elixir ones during rescue:</p>
<pre><code>try do
  :erlang.error(:badarg)
rescue
  ArgumentError -&gt; :ok
end</code></pre>
<p>The most common Erlang errors will be transformed into their
Elixir counter-part. Those which are not will be transformed
into <a href="ErlangError.html"><code class="inline">ErlangError</code></a>:</p>
<pre><code>try do
  :erlang.error(:unknown)
rescue
  ErlangError -&gt; :ok
end</code></pre>
<p>In fact, ErlangError can be used to rescue any error that is
not an Elixir error proper. For example, it can be used to rescue
the earlier <code class="inline">:badarg</code> error too, prior to transformation:</p>
<pre><code>try do
  :erlang.error(:badarg)
rescue
  ErlangError -&gt; :ok
end</code></pre>
<h2>Catching throws and exits</h2>
<p>The catch clause can be used to catch throws values and exits.</p>
<pre><code>try do
  exit(:shutdown)
catch
  :exit, :shutdown -&gt; IO.puts &quot;Exited with shutdown reason&quot;
end

try do
  throw(:sample)
catch
  :throw, :sample -&gt;
    IO.puts &quot;sample thrown&quot;
end</code></pre>
<p>catch values also support <code class="inline">:error</code>, as in Erlang, although it is
commonly avoided in favor of raise/rescue control mechanisms.</p>
<h2>Else clauses</h2>
<p>Else clauses allow the result of the expression to be pattern
matched on:</p>
<pre><code>x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end</code></pre>
<p>If an else clause is not present the result of the expression will
be return, if no exceptions are raised:</p>
<pre><code>x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end</code></pre>
<p>However when an else clause is present but the result of the expression
does not match any of the patterns an exception will be raised. This
exception will not be caught by a catch or rescue in the same try:</p>
<pre><code>x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError can not be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end</code></pre>
<p>Similarly an exception inside an else clause is not caught or rescued
inside the same try:</p>
<pre><code>try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end</code></pre>
<p>This means the VM no longer needs to keep the stacktrace once inside
an else clause and so tail recursion is possible when using a <code class="inline">try</code>
with a tail call as the final call inside an else clause. The same
is true for rescue and catch clauses.</p>
<h2>Variable handling</h2>
<p>Since an expression inside <code class="inline">try</code> may not have been evaluated
due to an exception, any variable created inside <code class="inline">try</code> cannot
be accessed externally. For instance:</p>
<pre><code>try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x #=&gt; unbound variable `x`</code></pre>
<p>In the example above, <code class="inline">x</code> cannot be accessed since it was defined
inside the <code class="inline">try</code> clause. A common practice to address this issue
is to return the variables defined inside <code class="inline">try</code>:</p>
<pre><code>x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1622" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="unquote/1">
    <span class="signature"><strong>unquote(expr)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#unquote/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Unquotes the given expression from inside a macro.</p>
<h2>Examples</h2>
<p>Imagine the situation you have a variable <code class="inline">value</code> and
you want to inject it inside some quote. The first attempt
would be:</p>
<pre><code>value = 13
quote do: sum(1, value, 3)</code></pre>
<p>Which would then return:</p>
<pre><code>{:sum, [], [1, {:value, [], quoted}, 3]}</code></pre>
<p>Which is not the expected result. For this, we use unquote:</p>
<pre><code>value = 13
quote do: sum(1, unquote(value), 3)
#=&gt; {:sum, [], [1, 13, 3]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1123" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="unquote_splicing/1">
    <span class="signature"><strong>unquote_splicing(expr)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#unquote_splicing/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Unquotes the given list expanding its arguments. Similar
to unquote.</p>
<h2>Examples</h2>
<pre><code>values = [2, 3, 4]
quote do: sum(1, unquote_splicing(values), 5)
#=&gt; {:sum, [], [1, 2, 3, 4, 5]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L1136" class="view_source">Source</a>
  
</section>
<section class="detail">
  <div class="detail_header" id="{}/1">
    <span class="signature"><strong>{args}</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#{}/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <section class="docstring">
    <p>Creates a tuple.</p>
<p>Only two item tuples are considered literals in Elixir.
Therefore all other tuples are represented in the AST
as a call to the special form <code class="inline">:{}</code>.</p>
<p>Conveniences for manipulating tuples can be found in the
<a href="Tuple.html"><code class="inline">Tuple</code></a> module. Some functions for working with tuples are
also available in <a href="Kernel.html"><code class="inline">Kernel</code></a>, namely <a href="Kernel.html#elem/2"><code class="inline">Kernel.elem/2</code></a>,
<a href="Kernel.html#put_elem/3"><code class="inline">Kernel.put_elem/3</code></a> and <a href="Kernel.html#tuple_size/1"><code class="inline">Kernel.tuple_size/1</code></a>.</p>
<h2>Examples</h2>
<pre><code>iex&gt; {1, 2, 3}
{1, 2, 3}

iex&gt; quote do: {1, 2, 3}
{:{}, [], [1,2,3]}</code></pre>

  </section>
  
    <a href="https://github.com/elixir-lang/elixir/blob/a7dbfd1e82d2061a9e1a88e8896c3d11f3fc9a0a/lib/elixir/lib/kernel/special_forms.ex#L43" class="view_source">Source</a>
  
</section>

        </section>
      

      
    </section>
  </body>
</html>
